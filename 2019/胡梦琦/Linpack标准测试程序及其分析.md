#Linpack标准测试程序及其分析
* * *
##目录
+ **概述**  
+ **HPL测试介绍**
+ **HPL的理论基础**
+ **部分代码解析**

###一、概述  
Linpack是国际上使用最广泛的测试高性能计算机系统浮点性能的基准测试。通过对高性能计算机采用高斯消元法求解一元 N次稠密线性代数方程组的测试评价高性能计算机的浮点计算性能。  
很多人把用Linpack基准测试出的最高性能指标作为衡量机器性能的标准之一。这个数字可以作为对系统峰值性能的一个修正。通过测试求解不同问题规模的实际得分，我们可以得到达到最佳性能的问题规模。
  
 Linpack 测试包括三类:  
 
**100×100的矩阵:** 
>求解规模为100阶的稠密线性代数方程组，它只允许采用编译优化选项进行优化，不得更改代码，甚至代码中的注释也不得修改。  
 
**1000×1000的矩阵:**
> 求解1000阶的线性代数方程组，达到指定的精度要求，可以在不改变计算量的前提下做算法和代码上做优化。  

**HPL:**  
>即High Performance Linpack，也叫高度并行计算基准测试，它对数组大小N没有限制，求解问题的规模可以改变，除基本算法（计算量）不可改变外，可以采用其它任何优化方法。目前，用Linpack基准测试出的最高性能指标已经成为衡量机器性能的标准之一，这个数字可以作为对系统峰值性能的一个修正。通过测试求解不同问题规模的实际计算速度值，我们不仅可以得到达到最佳性能的问题规模和性能测试数据。

###二、HPL测试介绍
Linpack 基准测试报告描述在求解计算密集型矩阵问题 Ax = b 时的性能，分为三个问题规模及相应的优化选项:100x100问题(内部循环优化)，1000 x1000问题(三级循环优化-整个程序)以及一个可扩展并行问题。 

使用HPL基准测试一般需要和收集的信息包括:   
>**Rpeak**		系统的最大的理论峰值性能，用GFLOPS 表示。  
**Nmax**	获得最高GFLOPS值时的矩阵规模或问题规模。  
**Rmax**	在 Nmax规定的问题规模下，达到的最大GFLOPS。  
**NB**	        对于数据分配和计算粒度，HPL使用的块尺度NB。

HPL是针对现代并行计算机提出的测试方式。用户在不修改任意测试程序的基础上，可以调节问题规模大小(矩阵大小)、使用CPU数目、使用各种优化方法等等来执行该测试程序，以获取最佳的性能。HPL采用高斯消元法求解线性方程组。求解问题规模为N时，浮点运算次数为(2/3* N3－2* N2)。因此，只要给出问题规模N，测得系统计算时间T，峰值=计算量(2/3* N3－2* N2)/计算时间T，测试结果以浮点运算每秒给出。HPL测试结果是TOP500排名的重要依据。

###三、HPL的理论基础
HPL 解决的是一个线性方程组求解的问题:   
Ax = b	;	A∈Rn·n 	;	x,b∈Rn  
通过对于方程式n行n + 1列的系数矩阵的行基本变换进行LU因式分解，最后得到:   
Ly = Pb   
Ux= y  
对列主元(即行的基等变换)LU分解算法如下:  
假设A为mxn矩阵L为 mxn 单位下三角矩阵,U为mxn上三角矩阵，P为mxm置换矩阵，P = Pn-1⋯Pi，Pj 为第j次循环完成第j行与主元行进行交换的置换矩阵。 
首先计算n×n + 1系数矩阵[A b] = [[L，U] y]的行局部旋转来计算LU分解来解决n阶线性系统：Ax = b。由于随着分解的进行将较低的三角因子L应用于b，因此通过求解较高的三角系Ux = y可获得解x.下三角矩阵L保持不旋转，并且不返回旋转数组。
 ![alt 图标](file:///Users/pro/Downloads/hpl-2.3/www/mat2.jpg)  
根据块循环方案，将数据分布到二维P-Q Q处理网格中，以确保“良好”的负载平衡以及算法的可伸缩性。首先将n×n + 1系数矩阵逻辑上划分为nb×nb块，这些块周期性地“降级”到Pby-Q处理网格上。这是在矩阵的两个维度上完成的。  
![alt 图标](file:///Users/pro/Downloads/hpl-2.3/www/main.jpg)

###四、部分代码解析
####向后替换：  
* **HPL_pdtrsv**     <u>void HPL_pdtrsv( HPL_T_grid *  GRID， HPL_T_pmat * AMAT )</u>   
HPL_pdtrsv 解决线性方程的上三角系统。rhs是N×N + 1矩阵A的最后一列。求解从拥有A的第N列的处理列开始，因此rhs b可能需要在开始处向左移一个处理列。因此，该例程在每个进程列中都需要一个列向量，但拥有b的列除外。结果将在所有进程行中复制，并以XR返回，即XR在所有进程中的大小均为nq = LOCq（N）。该算法在根据同步通信点对点原语实现的过程行和列中使用减少的单环广播。深度1的超前用于最小化关键路径。整个操作本质上是"等待时间''的限制，其运行时间的估算由下式给出:

		(移动rhs)lat + N /(P bdwth)+(解决)((N / NB）-1)2(lat + NB / bdwth)+ gam2 N ^ 2 / /(PQ)  
		其中gam2是对2级BLAS执行率。有N / NB个对角线块。一个人必须交换2个长度为NB的消息，以计算向量解的下一个NB项，以及执行总共N ^ 2个浮点运算。

GRID（本地输入)  HPL_T_grid *  
	在输入时，GRID指向包含以下内容的数据结构：
	处理网格信息。  
AMAT（本地输入/输出） HPL_T_pmat *  
	进入时，AMAT指向包含以下内容的数据结构：
      本地数组信息。 
        
         
####主要测试：
* **HPL_pdtest**
<u>void HPL_pdtest( HPL_T_test * TEST，HPL_T_grid * GRID,HPL_T_palg * ALGO,const int N,const int NB )</u>  
在给定一组参数（例如过程网格，问题大小，分布阻塞因子）的情况下，HPL_pdtest执行一个测试。此函数生成数据，调用并乘以线性系统求解器，检查获得的矢量解的准确性并写入将此信息保存到TEST-> outfp指向的文件中。

TEST（全局输入）HPL_T _test *  
        在输入时，TEST指向测试数据结构：outfp
        指定将在其中打印结果的输出文件。
        它仅由网格的进程0定义和使用。
        thrsh指定测试比率的阈值。
        具体而言，只有在以下情况下，才将测试声明为“通过”
        满足以下不等式：
        || Ax-b || _oo /（epsil *（|| x || _oo * || A || _oo + || b || _oo）* N）<阈值。
        epsil是分布式的相对机器精度电脑。最后是测试计数器kfail，kpass，kskip和
        ktest更新如下：如果测试通过，则kpass加一；如果测试失败，则kfail递增
        一个人 如果跳过测试，kskip将增加1。
        ktest保持不变。  
GRID（本地输入）HPL_ T_ grid *  
        在输入时，GRID指向包含以下内容的数据结构：
        处理网格信息。  
ALGO（全局输入）HPL_ T_ palg *  
        进入时，ALGO指向包含以下内容的数据结构：
        此测试要使用的算法参数。  
N（全局输入）const int  
        在输入时，N指定系数矩阵A的顺序。
        N必须至少为零。  
NB（全局输入）const int
        在输入时，NB指定用于分区的阻塞因子
        并分配矩阵A。NB必须大于1。  











